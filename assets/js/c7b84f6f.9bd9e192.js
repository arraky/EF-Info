"use strict";(self.webpackChunkef_website_template=self.webpackChunkef_website_template||[]).push([[175],{7386:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2023/03/10/arbeiten-an-API","metadata":{"permalink":"/EF-Info/2023/03/10/arbeiten-an-API","editUrl":"https://github.com/arraky/EF-Info/tree/main/blog/2023-03-10-arbeiten-an-API.md","source":"@site/blog/2023-03-10-arbeiten-an-API.md","title":"Arbeiten an einer API","description":"Der ganze Artikel ist kopiert und paraphrasiert von No0ne Blog","date":"2023-03-10T00:00:00.000Z","formattedDate":"10. M\xe4rz 2023","tags":[],"readingTime":1.545,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"nextItem":{"title":"numtrip-topdown","permalink":"/EF-Info/2023/1/23/numtrip-topdown"}},"content":"Der ganze Artikel ist kopiert und paraphrasiert von No0ne Blog\\n### 10.03.2023\\nHeute starteten wir, unsere eigene Simple API zu erstellen. Wir folgten der Anleitung auf der Website Schritt f\xfcr Schritt, um die API zu erstellen.\\n\\n## Postman\\n\\nMit der Third-Party Software Postman kann man eine Website aufrufen, ohne einen Browser zu verwenden. Dies funktioniert \xfcber die Methode GET. Ebenfalls kann man einfach Header-Informationen ver\xe4ndern, und auch andere Parameter ver\xe4ndern.\\n\\n![](images/postman.png)\\n\\nSo sieht Postman aus. Zuoberst im Bild kann man die gew\xfcnschte URL eingeben. Die Entsprechende Header-Information wird automatisch angef\xfcgt, wenn man darunter im Tab Parameter z.b. beim KEY text den parameter VALUE ver\xe4ndert.\\n\\nZuunterst siehtman die zur\xfcckgesendete JSON-Information, die von unserer API ver\xe4ndert wurde, und als `msg` zur\xfcckgegeben wird.\\n\\n## Verwenden von NODE-RED\\n\\nAuf NODE_RED ist unsere eigentliche API.\\n\\n![](images/node-red-api.png)\\n\\nDie API besteht aus 3 eigentlichen Teilen.\\nzuerst wird die URL `/api/to-emoji-lang` (Die seite selbst) aufgerufen. Danach wird im ersten `debug in` in die Konsole ausgegeben, was f\xfcr Information in der URL erhalten ist. Danach l\xe4uft genau diese Information durch die Funktion 4.\\n\\n![](images/function4.png)\\n\\nDiese Funktion funktioniert folgendermassen:\\n\\nAls erstes wird `emoji` gleichgesetzt mit dem Text des Inhaltes der von der Website abgerufen wird. Danach wird in diesem Text jedes \\"Hello\\" durch ein Winkesmiley und jedes \\"World\\" durch eine Weltkugel ersetzt. Danach wird die Payload der Nachricht zu emoji gesetzt, und diese Nachricht zur\xfcckgegeben.\\n\\nNun gibt es noch die Kontrolle im zweiten `debug out` wo wir in der Konsole sehen k\xf6nnen, dass es funktioniert hat. \\n\\nZum grossen Finale wird nun eine http Response gemacht, damit Postman auch unsere von der API ver\xe4nderte Nachricht bekommt.\\n\\n## Schlusswort / Fazit\\n\\nDie API auf unserem NODE-RED Server kommuniziert mit Postman. Die beiden Individuellen Programme \xfcbersetzen unsere Menschensprache in Emojis, und tun dies, ohne dass wir selbst etwas tun m\xfcssen. Den Prozess der Automation finde ich pers\xf6nlich sehr interessant, weil gut anwendbar."},{"id":"/2023/1/23/numtrip-topdown","metadata":{"permalink":"/EF-Info/2023/1/23/numtrip-topdown","editUrl":"https://github.com/arraky/EF-Info/tree/main/blog/2023-1-23-numtrip-topdown.md","source":"@site/blog/2023-1-23-numtrip-topdown.md","title":"numtrip-topdown","description":"1","date":"2023-01-23T00:00:00.000Z","formattedDate":"23. Januar 2023","tags":[],"readingTime":4.07,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"Arbeiten an einer API","permalink":"/EF-Info/2023/03/10/arbeiten-an-API"},"nextItem":{"title":"What was it all for?","permalink":"/EF-Info/2023/1/13/numtrip-conclusion"}},"content":"![](./Top-Down-Picture/Top-Down.svg)\\n# Functions\\n## 1\\n```py\\nfor m in range(Row):\\n     field.append([])\\n     for n in range(Coloumns):\\n         Num = 2**(randint(0,3))\\n         field[m].append(Num)\\n```\\n## 2\\n```py\\ndef fieldnum():\\n    print(\'  \',end=\'\')\\n    for i in range(Row):\\n        print(\'   \',i, end=\'  \')\\n    print(\'\')\\n\\ndef line():\\n    print(\'  \', end=\'\')\\n    for i in range(Row):\\n        print(\'+------\',end=\'\')\\n    print(\'+\')\\n\\ndef playground():\\n    fieldnum()\\n    for i in range(Row):\\n        line()\\n        print(i,end=\' \')\\n        for j in range(Coloumns):\\n            if 100>field[i][j] >10:\\n                print(f\'| \',field[i][j], end=\'  \')\\n            elif 1000>field[i][j] >100:\\n                print(f\'| \',field[i][j], end=\' \')\\n            else:\\n                print(f\'|  \',field[i][j], end=\'  \')\\n            \\n        print(\'|\')\\n    line()\\n```\\n## 3\\n```py\\ndef replacetop():\\n    pass\\n    #function at header 11\\n```\\n## 4\\n```py\\nadjlist = []\\ndef checkadj(x,y,oldy,oldx):\\n    pass\\n    #function at header 10\\n\\ndef checkdel_and_double():\\n    if checkadj(x,y,oldy,oldx) is True:\\n        field[oldy][oldx] = 2*oldfield #doubles the value of our original field if checkadj() is True\\n```\\n## 5\\n```py\\nwhile endgameloss() is False:\\n    if roundcount == 0: #show it the first time\\n        playground()\\n    else:\\n        pass\\n\\n    x = X_Inputcheck(\'X Axis:\') #Inputs\\n    y = Y_Inputcheck(\'Y Axis:\')\\n\\n    oldy,oldx = y,x #Stores values for later\\n    oldfield = field[y][x]\\n\\n    print(f\'You chose the field with the number:\', field[y][x]) #Inform the player that the right field was chosen\\n\\n    checkdel_and_double() #Recursion delete\\n    replacetop() #Fill up\\n\\n    adjlist.clear() #Clear list, so it doesn\'t annoy us in the next round\\n    if endgamewin() is True: #Check if win condition is met; if so -> Congratulations\\n        playground()\\n        print(f\'You won! It took you {roundcount} rounds\')\\n        break\\n    roundcount+=1 #counts the rounds\\n    print(\'New Field:\')\\n    playground() #show the end result so that you can play again\\n```\\n## 6\\n```py\\ndef endgameloss():\\n    global field\\n    endgameplayfield = [x[:] for x in field] #copies the whole field into endgameplayfield as a backup copy\\n    for i in range(5):\\n        for j in range(5):\\n            if checkadj(j,i, oldx=j, oldy=i) is True:\\n                field = [x[:] for x in endgameplayfield] #copy every element back\\n                adjlist.clear() #clear list so it doesn\'t affect the actual game\\n                return False #Continue Game\\n    playground()\\n    print(f\'Alas, you lost! You lasted {roundcount} rounds\')\\n    return True #Loss\\n\\ndef endgamewin():\\n    for i in range(5):\\n        for j in range(5):\\n            if field[i][j] == 256: #if any field has the value 256, it\'s a win\\n                return True#Win\\n```\\n## 7\\n```py\\ndef X_Inputcheck(Questionx):\\n    inpx = \\"\\".join(filter(lambda x: x in [\'0\',\'1\',\'2\',\'3\',\'4\',\'-\'],input(Questionx))) \\n    #Lambda defines a function here: Filter out everything that\'s not in \'0123456789-\'\\n    while len(inpx)!=1: #len(inpx) must be 1. if not, inputs like \'01\' or \'012\' would be allowed\\n        print(\'input not valid\')\\n        inpx = \\"\\".join(filter(lambda x: x in [\'0\',\'1\',\'2\',\'3\',\'4\',\'-\'],input(Questionx)))\\n    numx=int(inpx)\\n    return numx\\n\\ndef Y_Inputcheck(Questiony):\\n    inpy = \\"\\".join(filter(lambda x: x in [\'0\',\'1\',\'2\',\'3\',\'4\',\'-\'],input(Questiony)))\\n    while len(inpy)!=1:\\n        print(\'input not valid\')\\n        inpy = \\"\\".join(filter(lambda x: x in [\'0\',\'1\',\'2\',\'3\',\'4\',\'-\'],input(Questiony)))\\n    numy=int(inpy)\\n    return numy\\n```\\n## 8\\n```py\\ndef playground():\\n    field[i][j] #this part in the playground function\\n```\\n## 9\\n```py\\n#This part in the gameloop:\\n    x = X_Inputcheck(\'X Axis:\') #Inputs\\n    y = Y_Inputcheck(\'Y Axis:\')\\n\\n    oldy,oldx = y,x #Stores values for later\\n    oldfield = field[y][x]\\n```\\n## 10\\n```py\\ndef checkadj(x,y,oldy,oldx):\\n    left = (x > 0 and field[y][x] == field[y][x - 1] and field[y][x]!=0) or False #expressions to make life easier\\n    right = (x < 4 and field[y][x] == field[y][x + 1] and field[y][x]!=0) or False # if x isn\'t bigger than 4 -> no out of bounds error\\n    up = (y > 0 and field[y][x] == field[y - 1][x] and field[y][x]!=0) or False #looks if field upwards is same as our current field\\n    down = (y < 4 and field[y][x] == field[y + 1][x] and field[y][x]!=0) or False #current field != 0, otherwise, in some cases there\'s going to be infinite loops (we don\'t like those)\\n    anyadj = left or right or up or down\\n\\n    \\n    if not anyadj and (y!=oldy or x!=oldx): #if you advance into some field, and around this field nothing is same, it should return to original field\\n        field[y][x] = 0\\n        y,x = oldy,oldx\\n        \\n    elif not anyadj: #stop if there\'s nothing in the first place\\n        return False\\n\\n    else:\\n        if down:\\n            adjlist.append([y+1,x]) #append element to adjlist\\n            field[y][x] = 0 #set current field to 0 -> no infinite loops\\n            checkadj(x,y+1,oldy,oldx) #repeat whole function at the element we added to adjlist\\n        if left:\\n            adjlist.append([y,x-1])\\n            field[y][x] = 0\\n            checkadj(x-1,y,oldy,oldx)\\n        if right:\\n            adjlist.append([y,x+1])\\n            field[y][x] = 0\\n            checkadj(x+1,y,oldy,oldx)\\n        if up:\\n            adjlist.append([y-1,x])\\n            field[y][x] = 0\\n            checkadj(x,y-1,oldy,oldx)\\n        return True\\n```\\nTakes the values as parameters in the function bracket\\n## 11\\nTakes the emptied field and refills it using the adjlist from the recursion algorithm\\n```py\\ndef replacetop():\\n    adjlist.sort() #sorts the list -> prevents errors\\n    for i in range(len(adjlist)):\\n        dy = adjlist[i][0] #easy life expressions\\n        dx = adjlist[i][1]\\n        while dy != 0:\\n            field[dy][dx] = field[dy-1][dx]\\n            field[dy-1][dx] = 0\\n            dy-=1 #go up one field\\n        field[0][dx] = 2**(randint(0,3)) #fill up the field at the top with a new number\\n```\\n## 12\\n```py\\n#this part in the gameloop\\nif endgamewin() is True: #Check if win condition is met; if so -> Congratulations\\n        playground()\\n        print(f\'You won! It took you {roundcount} rounds\')\\n        break\\n```\\n## 13\\n```py\\n#This part in the gameloop\\nprint(\'New Field:\')\\nplayground() #show the end result so that you can play again\\n```"},{"id":"/2023/1/13/numtrip-conclusion","metadata":{"permalink":"/EF-Info/2023/1/13/numtrip-conclusion","editUrl":"https://github.com/arraky/EF-Info/tree/main/blog/2023-1-13-numtrip-conclusion.md","source":"@site/blog/2023-1-13-numtrip-conclusion.md","title":"What was it all for?","description":"In my opinion,the goal of this game was to introduce us students to the fundamentals of Python. We knew the game mechanics from the very beginning, we had total freedom on what approach we would take. Everyone took his own approach, some parts in the code will strongly resemble each other, but as long as everybody knows what their code does, who cares?","date":"2023-01-13T00:00:00.000Z","formattedDate":"13. Januar 2023","tags":[],"readingTime":2.395,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"numtrip-topdown","permalink":"/EF-Info/2023/1/23/numtrip-topdown"},"nextItem":{"title":"Working game?","permalink":"/EF-Info/2022/12/31/numtrip-update"}},"content":"In my opinion,the goal of this game was to introduce us students to the fundamentals of Python. We knew the game mechanics from the very beginning, we had total freedom on what approach we would take. Everyone took his own approach, some parts in the code will strongly resemble each other, but as long as everybody knows what their code does, who cares?\\n\\nI\'m now able to have an idea, and know how to do it in python, based on my current knowledge. For example, I currently think about trying to program a chess board in python that could take inputs from played games in the common chess notation (e.g. Nxg4). \\n\\n# The realisation of the game\\n## Requirement\\n+ Python 3.10 (2.0 is outdated and syntax is different)\\n## Top-Down\\n[Link to Top-Down-Diagram](/blog/2023-1-23-numtrip-topdown.md)\\n## Explanation of my refill field function\\n```py\\ndef replacetop():\\n    adjlist.sort()\\n    for i in range(len(adjlist)):\\n        dy = adjlist[i][0] #easy life expressions\\n        dx = adjlist[i][1]\\n        while dy != 0:\\n            field[dy][dx] = field[dy-1][dx]\\n            field[dy-1][dx] = 0\\n            dy-=1 #go up one field\\n        field[0][dx] = 2**(randint(0,3)) #fill up the field at the top with a new number\\n```\\nAdjlist is the list containing the emptied fields. It now sorts the list, the fields at the top will go through the following algorithm first, preventing some errors.\\n\\n```py\\nfor i in range(len(adjlist)):\\n```\\nRepeat the algorithm for every element in the Adjlist\\n\\n```py\\ndy = adjlist[i][0]\\ndx = adjlist[i][1]\\n```\\nThis makes working and writing the code substantially easier as the name is way shorter. Now to the actual algorithm:\\n```py\\nwhile dy != 0:\\n    field[dy][dx] = field[dy-1][dx]\\n    field[dy-1][dx] = 0\\n    dy-=1 \\nfield[0][dx] = 2**(randint(0,3)) \\n```\\nIn short, the algorithm takes the element \'i\' in the adjlist and takes the value from the cell above our emptied cell. It repeats this until we hit the top by using a while loop that always goes up one cell.\\n```py\\ndy-=1 #this makes the whole loop repeat until we hit the top\\n```\\nOnce we hit the top, we can\'t take no number from above anymore, so we generate one instead:\\n```py\\nfield[0][dx] = 2**(randint(0,3))\\n```\\n# Biggest challenge\\n## Frustration while trying to get the recursion to work\\nI\'ve never done a recursion code before, but I knew intuitively what it was supposed to do. I tried and tried and in my mind, my codes made sense, but the program didn\'t *get* them. I felt stupid and annoyed with myself for taking so long getting it to work.\\n\\nThe rest was pretty easy in comparison\\n# My advice for new students\\n## Take use of the things you learned\\nEspecially lists, those are very important and make the game development a lot easier and more enjoyable in general.\\n## Keep at it!\\nThere\'s nothing like the euphoria you get when something that you\'ve been working on for months suddenly works flawlessly"},{"id":"/2022/12/31/numtrip-update","metadata":{"permalink":"/EF-Info/2022/12/31/numtrip-update","editUrl":"https://github.com/arraky/EF-Info/tree/main/blog/2022-12-31-numtrip-update.md","source":"@site/blog/2022-12-31-numtrip-update.md","title":"Working game?","description":"Inputchecks","date":"2022-12-31T00:00:00.000Z","formattedDate":"31. Dezember 2022","tags":[],"readingTime":4.3,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"What was it all for?","permalink":"/EF-Info/2023/1/13/numtrip-conclusion"},"nextItem":{"title":"Recursion","permalink":"/EF-Info/2022/12/6/numtrip-update"}},"content":"## Inputchecks\\nI removed the is_integer function and replaced it with a function in the X and Y Inputcheck:\\n```py\\n    inpx = \\"\\".join(filter(lambda x: x in [\'0\',\'1\',\'2\',\'3\',\'4\',\'5\',\'6\',\'7\',\'8\',\'9\',\'-\'],input(Questionx))) \\n```\\nLambda defines a function here: Filter out everything that\'s not in \'0123456789-\'\\n\\nIt then goes on about and checks if the if the len(inpx) is 1. \\nIf that\'s not the case, it tells you to f*ck off.\\n\\njk \\n\\nIt just tells you the input was invalid and the whole process starts anew.\\n\\n## Chechadj()\\nIt has a global adjacent list \\"adjlist\\". TBH I took this idea from Thomas (props to him). \\n\\n- The function now has 4 parameters instead of 2: x,y,oldx and oldy. Again, too fix \\"referenced before assignment errors\\"\\n\\n- Instead of not_left, not_right etc. the functions now check if there is something instead of nothing -> \\n```py\\n        left = (x > 0 and field[y][x] == field[y][x - 1] and field[y][x]!=0) or False\\n```\\n- Now, most importantly, I got the recursion to work: E.g. If left, it appends this field to the adjlist, sets the current field to 0 and repeats the function on the square to the left\\n```py\\n        if left:\\n            adjlist.append([y,x-1])\\n            field[y][x] = 0\\n            checkadj(x-1,y,oldy,oldx)\\n```\\n\\n## Replacetop()\\n- It takes the adjlist and sorts it at the beginning, so that it works from the top of the field downwards. This fixes some errors.\\n- I gave each element in the adjlist a name in a for loop:\\n```py\\n        for i in range(len(adjlist)):\\n        dy = adjlist[i][0]\\n        dx = adjlist[i][1]\\n```\\n- The function takes the number from the field from above and puts it into field[dy][dx] and replaces this top field with 0. Dy is subtracted by 1 and the process begins again for the field that currently has a 0 in it. The moment it reaches the top, it gives this square a new number:\\n```py\\n        while dy != 0:\\n            field[dy][dx] = field[dy-1][dx]\\n            field[dy-1][dx] = 0\\n            dy-=1\\n        field[0][dx] = 2**(randint(0,3))\\n```\\n## Giveup()\\nI provisorically created this function as a jump in for the lack of a working endgame() function. I may change it to a stop game function that saves the current playfield via JSON to another file. \\n\\n## Endgameloss()\\nThis function checks on the whole field, if there\'s even a possible merge of fields. For this, I chose my function chechadj(x,y,oldx,oldy). To make it work, I had to create a new list \\"endgameplayfield\\", which copies the whole content of the playfield\\n```py\\n    global field\\n    endgameplayfield = [x[:] for x in field]\\n```\\n\\n\\nNow in two for loops, it checks if Checkadj() is true. In checkadj() fields change their values though, so in the end, it copies those values back from the endgameplayfield\\n```py\\n    for i in range(5):\\n        for j in range(5):\\n            if checkadj(j,i, oldx=j, oldy=i) is True:\\n                field = [x[:] for x in endgameplayfield]\\n                adjlist.clear()\\n                return False #Continue game\\n```\\nThe return False tells my gameloop to continue. If there\'s no field to merge, you lost and it stops the loop and gives the player a game over message:\\n```py\\n    print(f\'Alas, you lost! You lasted {roundcount} rounds\')\\n    return True #Loss\\n```\\n\\nThe roundcount is in the gameloop\\n\\n## Endgamewin()\\nThis function takes every value in the field and looks for the winning number, I set it to 256 for now. \\n```py\\n    for i in range(5):\\n        for j in range(5):\\n            if field[i][j] == 256:\\n                return True#Win\\n```\\n## Gameloop:\\n```py\\n    while endgameloss() is False:\\n    if roundcount == 0: #show it the first time\\n        playground()\\n    else:\\n        pass\\n\\n    x = X_Inputcheck(\'X Axis:\') #Inputs\\n    y = Y_Inputcheck(\'Y Axis:\')\\n\\n    oldy,oldx = y,x #Stores values for later\\n    oldfield = field[y][x]\\n\\n    print(f\'You chose the field with the number:\', field[y][x]) #Inform the player that the right field was chosen\\n\\n    checkdel_and_double() #Recursion delete\\n    replacetop() #Fill up\\n\\n    adjlist.clear() #Clear list, so it doesn\'t annoy us in the next round\\n    if endgamewin() is True: #Check if win condition is met; if so -> Congratulations\\n        print(f\'You won! It took you {roundcount} rounds\')\\n        break\\n    roundcount+=1 #counts the rounds\\n    print(\'New Field:\')\\n    playground() #show the end result so that you can play again\\n```\\nI wrote the most important infos in it already. \\n\\n1. It starts by showing the player the playground in round 0. \\n2. Asks for inputs and stores those values for later.\\n3. I added a small print that shows the player the number in the field he chose.\\n4. Goes through the recursion and filling up functions\\n5. Clears the adjlist for the next roudn\\n6. Checks if you\'ve won and shows the amount of rounds it took you\\n7. Adds 1 to the roundcount and shows the new field\\n\\n## Game with variable field sizes\\nIt\'s basically the same thing, I just replaced the hard written code (values like 4 and 5) with variables \\"Col\\" and \\"Row\\". At the beginning of the game, the player is asked for the size of the field. The input is checked through the same functions as X and Y_Inputcheck.\\n\\nI must rewrite it though, as it currently allows for 1x1 fields which obviously don\'t work. And even other fields such as 1x5 tend to have no solution as it\'s all based on random (pseudorandom to be exact) numbers."},{"id":"/2022/12/6/numtrip-update","metadata":{"permalink":"/EF-Info/2022/12/6/numtrip-update","editUrl":"https://github.com/arraky/EF-Info/tree/main/blog/2022-12-6-numtrip-update.md","source":"@site/blog/2022-12-6-numtrip-update.md","title":"Recursion","description":"This is the theme of this blog entry","date":"2022-12-06T00:00:00.000Z","formattedDate":"6. Dezember 2022","tags":[],"readingTime":2.22,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"Working game?","permalink":"/EF-Info/2022/12/31/numtrip-update"},"nextItem":{"title":"My reentry into Python","permalink":"/EF-Info/2022/08/26/python-reentry"}},"content":"This is the theme of this blog entry\\n\\n## New Functions\\n\\n### Checkdel_and_double()\\nA small function to check if you should double the content of field[y][x]:\\n```py\\n    def checkdel_and_double():\\n        if checkadj(x,y) is True:\\n            field[y][x] = 2*oldfield\\n            return True\\n```\\n### Replacetop()\\nIf the top field is emptied, it can\'t take numbers from above as their are no rows above it (obviously). Thus created a function (haven\'t implemented it yet) that creates new numbers similar to the random numbers filling up field[] at the beginning of the code\\n```py\\n    def replacetop():\\n        if field[0][x] == 0:\\n            field[0][x] == 2**(randint(0,6))\\n```\\n### Endgame()\\nAgain a function that I haven\'t implemented yet. It\'s supposed to constantly check the whole field for a possible field to be marked.\\n```py\\n    def endgame():\\n        for x in range(4):\\n            for y in range(4):\\n                if field[y][x] != field[y+1][x] or y!=4 and y!=0 or field[y-1][x] and field[y][x+1] or x!=4 and field[y][x-1] or x!=0:\\n                    return True\\n```\\n### Is_integer(n):\\nCopied that from the internet. It checks if the input is a float or an integer. Needed it for X- and Y-Inputcheck, because otherwise the program crashed with inputs like \'0.1\'\\n```py\\n    def is_integer(n):\\n        try:\\n            float(n)\\n        except ValueError:\\n            return False\\n        else:\\n            return float(n).is_integer()\\n```\\n## Changes to checkadj(x,y)\\nAdded parameters in paranthesis to account for error \\"referenced before assignment\\"\\n\\n### Added a not_left, not_right etc.\\nstatement with or False at the end so I could all put it into the statement \\"noadj\\"\\n```py\\n    not_left = (x > 0 and field[y][x] != field[y][x - 1]) or False\\n    not_right = (x < 4 and field[y][x] != field[y][x + 1]) or False\\n    not_up = (y > 0 and field[y][x] != field[y - 1][x]) or False\\n    not_down = (y < 4 and field[y][x] != field[y + 1][x]) or False\\n    noadj = not_left and not_right and not_up and not_down\\n```\\n### Added an if and elif statement\\nAfter you check the surroundings of field[y][x], say [y][x+1] and [y][x-1] have the same number in them. My code then empties [y][x] to allow for recursion (otherwise infinite loop between [y][x] and [y][x+1]) and goes to [y][x+1] to check this field\'s surroundings (Recursion). If it doesn\'t find anything new, it should return to the original y and x values to check at [y][x-1]. Thus I added this in my play loop: \\n```py\\n    oldx = x\\n    oldy = y\\n    oldfield = field[y][x]\\n\\nand this in checkadj(x,y):\\n    \\n    if noadj and (y!=oldy or x!=oldx):\\n        field[y][x] = 0\\n        y=oldy\\n        x=oldx\\n\\n    elif noadj:\\n        return False\\n```\\n### Started to try recursion\\nI have four modules, one for each direction. The [y+1][x] module looks like this:\\n```py\\n    if y!=4 and field[y+1][x] == field[y][x]:\\n        field[y][x] = 0\\n        y+=1\\n        checkadj(x,y)\\n        return True\\n```"},{"id":"/2022/08/26/python-reentry","metadata":{"permalink":"/EF-Info/2022/08/26/python-reentry","editUrl":"https://github.com/arraky/EF-Info/tree/main/blog/2022-08-26-python-reentry.md","source":"@site/blog/2022-08-26-python-reentry.md","title":"My reentry into Python","description":"Introduction","date":"2022-08-26T00:00:00.000Z","formattedDate":"26. August 2022","tags":[],"readingTime":0.68,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"Recursion","permalink":"/EF-Info/2022/12/6/numtrip-update"}},"content":"## Introduction\\nIn the first second, I was completly lost only understanding the simple commands\\n```py\\n    from turtle import *\\n\\n    forward(n)\\n    left(m)\\n```\\nWhen we had to draw the side of a die that shows a five, my inner perfectionist came out and made a mess of a code:\\n```py\\n    from turtle import *\\n\\n    forward(2)\\n    left(90)\\n    penup()\\n    forward(2)\\n    dot(10)\\n    right(180)\\n    forward(2)\\n    left(90)\\n    pendown()\\n\\n    forward(76)\\n    left(90)\\n\\n    penup()\\n    forward(2)\\n    dot(10)\\n    right(180)\\n    forward(2)\\n    left(90)\\n    pendown()\\n\\n    forward(2)\\n    left(90)\\n    forward(76)\\n\\n    penup()\\n    left(90)\\n    forward(2)\\n    dot(10)\\n    right(180)\\n    forward(2)\\n    left(90)\\n    pendown()\\n\\n    forward(2)\\n    left(90)\\n    forward(76)\\n\\n    penup()\\n    left(90)\\n    forward(2)\\n    dot(10)\\n    right(180)\\n    forward(2)\\n    left(90)\\n    pendown()\\n\\n    forward(2)\\n    left(90)\\n    forward(38)\\n\\n    penup()\\n    left(90)\\n    forward(40)\\n    dot(10)\\n    right(180)\\n    forward(40)\\n    left(90)\\n    pendown()\\n    forward(36)\\n\\n    hideturtle()\\n```\\nThis code........literally repeats itself 3 times. I\'m not quite happy about this code, but I won\'t bother making it any shorter as that\'s where my perfectionism ends :)"}]}')}}]);