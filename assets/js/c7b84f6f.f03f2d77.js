"use strict";(self.webpackChunkef_website_template=self.webpackChunkef_website_template||[]).push([[175],{7386:n=>{n.exports=JSON.parse('{"blogPosts":[{"id":"/2022/12/6/numtrip-update","metadata":{"permalink":"/EF-Info/2022/12/6/numtrip-update","editUrl":"https://github.com/arraky/EF-Info/tree/main/blog/2022-12-6-numtrip-update.md","source":"@site/blog/2022-12-6-numtrip-update.md","title":"Recursion","description":"This is the theme of this blog entry","date":"2022-12-06T00:00:00.000Z","formattedDate":"6. Dezember 2022","tags":[],"readingTime":2.15,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"nextItem":{"title":"My reentry into Python","permalink":"/EF-Info/2022/08/26/python-reentry"}},"content":"This is the theme of this blog entry\\n\\n## New Functions\\n\\n### Checkdel_and_double()\\nA small function to check if you should double the content of field[y][x]:\\n\\n    def checkdel_and_double():\\n        if checkadj(x,y) is True:\\n            field[y][x] = 2*oldfield\\n            return True\\n\\n### Replacetop()\\nIf the top field is emptied, it can\'t take numbers from above as their are no rows above it (obviously). Thus created a function (haven\'t implemented it yet) that creates new numbers similar to the random numbers filling up field[] at the beginning of the code\\n\\n    def replacetop():\\n        if field[0][x] == 0:\\n            field[0][x] == 2**(randint(0,6))\\n\\n### Endgame()\\nAgain a function that I haven\'t implemented yet. It\'s supposed to constantly check the whole field for a possible field to be marked.\\n\\n    def endgame():\\n        for x in range(4):\\n            for y in range(4):\\n                if field[y][x] != field[y+1][x] or y!=4 and y!=0 or field[y-1][x] and field[y][x+1] or x!=4 and field[y][x-1] or x!=0:\\n                    return True\\n\\n### Is_integer(n):\\nCopied that from the internet. It checks if the input is a float or an integer. Needed it for X- and Y-Inputcheck, because otherwise the program crashed with inputs like \'0.1\'\\n\\n    def is_integer(n):\\n        try:\\n            float(n)\\n        except ValueError:\\n            return False\\n        else:\\n            return float(n).is_integer()\\n\\n## Changes to checkadj(x,y)\\nAdded parameters in paranthesis to account for error \\"referenced before assignment\\"\\n\\n### Added a not_left, not_right etc.\\nstatement with or False at the end so I could all put it into the statement \\"noadj\\"\\n\\n    not_left = (x > 0 and field[y][x] != field[y][x - 1]) or False\\n    not_right = (x < 4 and field[y][x] != field[y][x + 1]) or False\\n    not_up = (y > 0 and field[y][x] != field[y - 1][x]) or False\\n    not_down = (y < 4 and field[y][x] != field[y + 1][x]) or False\\n    noadj = not_left and not_right and not_up and not_down\\n\\n### Added an if and elif statement\\nAfter you check the surroundings of field[y][x], say [y][x+1] and [y][x-1] have the same number in them. My code then empties [y][x] to allow for recursion (otherwise infinite loop between [y][x] and [y][x+1]) and goes to [y][x+1] to check this field\'s surroundings (Recursion). If it doesn\'t find anything new, it should return to the original y and x values to check at [y][x-1]. Thus I added this in my play loop: \\n    \\n    oldx = x\\n    oldy = y\\n    oldfield = field[y][x]\\n\\nand this in checkadj(x,y):\\n    \\n    if noadj and (y!=oldy or x!=oldx):\\n        field[y][x] = 0\\n        y=oldy\\n        x=oldx\\n\\n    elif noadj:\\n        return False\\n\\n### Started to try recursion\\nI have four modules, one for each direction. The [y+1][x] module looks like this:\\n\\n    if y!=4 and field[y+1][x] == field[y][x]:\\n        field[y][x] = 0\\n        y+=1\\n        checkadj(x,y)\\n        return True"},{"id":"/2022/08/26/python-reentry","metadata":{"permalink":"/EF-Info/2022/08/26/python-reentry","editUrl":"https://github.com/arraky/EF-Info/tree/main/blog/2022-08-26-python-reentry.md","source":"@site/blog/2022-08-26-python-reentry.md","title":"My reentry into Python","description":"Introduction","date":"2022-08-26T00:00:00.000Z","formattedDate":"26. August 2022","tags":[],"readingTime":0.66,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"Recursion","permalink":"/EF-Info/2022/12/6/numtrip-update"}},"content":"## Introduction\\nIn the first second, I was completly lost only understanding the simple commands\\n\\n    from turtle import *\\n\\n    forward(n)\\n    left(m)\\n\\nWhen we had to draw the side of a die that shows a five, my inner perfectionist came out and made a mess of a code:\\n\\n    from turtle import *\\n\\n    forward(2)\\n    left(90)\\n    penup()\\n    forward(2)\\n    dot(10)\\n    right(180)\\n    forward(2)\\n    left(90)\\n    pendown()\\n\\n    forward(76)\\n    left(90)\\n\\n    penup()\\n    forward(2)\\n    dot(10)\\n    right(180)\\n    forward(2)\\n    left(90)\\n    pendown()\\n\\n    forward(2)\\n    left(90)\\n    forward(76)\\n\\n    penup()\\n    left(90)\\n    forward(2)\\n    dot(10)\\n    right(180)\\n    forward(2)\\n    left(90)\\n    pendown()\\n\\n    forward(2)\\n    left(90)\\n    forward(76)\\n\\n    penup()\\n    left(90)\\n    forward(2)\\n    dot(10)\\n    right(180)\\n    forward(2)\\n    left(90)\\n    pendown()\\n\\n    forward(2)\\n    left(90)\\n    forward(38)\\n\\n    penup()\\n    left(90)\\n    forward(40)\\n    dot(10)\\n    right(180)\\n    forward(40)\\n    left(90)\\n    pendown()\\n    forward(36)\\n\\n    hideturtle()\\n\\nThis code........literally repeats itself 3 times. I\'m not quite happy about this code, but I won\'t bother making it any shorter as that\'s where my perfectionism ends :)"}]}')}}]);